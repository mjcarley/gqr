/* Copyright (C) 2020 by Michael Carley */

/**********************************************************************
 *
 * This file is part of gqr.
 *
 * gqr is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * gqr is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
 * License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with gqr.  If not, see <http://www.gnu.org/licenses/>.
 *
 **********************************************************************/

/*
  rank revealing QR factorizations
*/

#include <stdio.h>
#include <math.h>
#include <string.h>

#include <glib.h>

#include <gsl/gsl_math.h>
#include <gsl/gsl_sf.h>

#include <blaswrap.h>

#include "gqr.h"
#include "gqr-private.h"

gint dgeqp3_(gint *m, gint *n, gdouble *A, gint *lda, gint *jpvt,
	     gdouble *tau, gdouble *work, gint *lwork, gint *info) ;

gint dlarf_(gchar *side, gint *m, gint *n, gdouble *v, gint *incv,
	    gdouble *tau, gdouble *C, gint *ldc, gdouble *work) ;

/* gint dtrtrs_(gchar *uplo, gchar *trans, gchar *diag, */
/* 	     gint *n, gint *nrhs, gdouble *a, gint *lda, gdouble *b, */
/* 	     gint *ldb, gint *info) ; */
gint dtrtri_(gchar *uplo, gchar *diag, gint *n, gdouble *a,
	     gint *lda, gint *info) ;
void drotg_(gdouble *da, gdouble *db, gdouble *c, gdouble *s) ;
void drot_(gint *N, gdouble *dx, gint *incx, gdouble *dy, gint *incy,
	   gdouble *C, gdouble *S) ;

#define matrix_index(_m,_n,_i,_j) ((_i) + (_j)*(_m))

static gint column_swap(gdouble *a, gint m, gint n, gint j, gint k)

{
  gint one = 1 ;
  
  blaswrap_dswap(m,
		 &(a[matrix_index(m,n,0,j)]), one,
		 &(a[matrix_index(m,n,0,k)]), one) ;
  return 0 ;
}

static gint column_shuffle(gdouble *a, gint m, gint n, gint j0, gint lda)

{
  gint i, j ;
  gdouble tmp ;

  for ( i = 0 ; i < m ; i ++ ) {
    tmp = a[matrix_index(lda,n,i,j0)] ;
    for ( j = j0 ; j < n ; j ++ ) {
      a[matrix_index(lda,n,i,j)] = a[matrix_index(lda,n,i,j+1)] ;
    }
    a[matrix_index(lda,n,i,n)] = tmp ;
  }

  return 0 ;
}  

static gint row_shuffle(gdouble *a, gint m, gint n, gint i0, gint i1, gint lda)

{
  gint i, j ;
  gdouble tmp ;

  for ( j = 0 ; j < n ; j ++ ) {
    tmp = a[matrix_index(m,n,i0,j)] ;
    for ( i = i0 ; i < i1 ; i ++ ) {
      a[matrix_index(m,n,i,j)] = a[matrix_index(lda,n,i+1,j)] ;
    }
    a[matrix_index(m,n,i1,j)] = tmp ;
  }

  return 0 ;
}  

static gint array_shuffle_int(gint *a, gint n, gint i0)

{
  gint tmp, i ;
  
  tmp = a[i0] ;
  
  for ( i = i0 ; i < n ; i ++ ) a[i] = a[i+1] ;
  a[n] = tmp ;
    
  return 0 ;
}

static gint array_shuffle_double(gdouble *a, gint n, gint i0)

{
  gint i ;
  gdouble tmp ;
  
  tmp = a[i0] ;
  
  for ( i = i0 ; i < n ; i ++ ) a[i] = a[i+1] ;
  a[n] = tmp ;
    
  return 0 ;
}

gint gqr_srrqr(gdouble *A, gint m, gint n, gdouble f, gdouble tol,
	       gdouble *Q, gdouble *R, gint *pvt, gint *rank, gint *ldr,
	       gdouble *work, gint lwork)

/*
 * algorithm of Gu and Eisenstat, based on the Matlab code of Xu Xing
 *
 */
  
{
  gdouble *tau, *AB, *gamma, *omega, tmp, *Atmp ;
  gdouble ta, tb, Gs, Gc ;
  gdouble ga, mu, nu, rho, ga_bar ;
  gdouble *b1, *b2, *u1, *u2, *c1T, *c2T, *c1Tbar, *c2Tbar ;
  gint info, i, j, k, mab, nab, n12, ii, itmp, iter, one = 1 ;
  gint nr, mr, lw, Rm, len ;
  
  /*do the pivoting QR factorization*/
  memset(pvt, 0, MAX(m,n)*sizeof(gint)) ;
  /* lw = 3*n+1 ; */
  lw = -1 ; tau = NULL ;
  dgeqp3_(&m, &n, A, &m, pvt, tau, work, &lw, &info) ;
  lw = work[0] ;
  tau = &(work[lw]) ; 
  dgeqp3_(&m, &n, A, &m, pvt, tau, work, &lw, &info) ;

  /* gamma = &(work[0]) ;  
  
  /*subtract one from pvt to convert to C indexing*/
  for ( i = 0 ; i < n ; i ++ ) pvt[i] -= 1 ;
  
  /*find the rank*/
  for ( k = 1 ; k < MIN(m,n) ; k ++ ) {
    if ( fabs(A[matrix_index(m,n,k,k)]) < tol ) break ;
  }

  /*size R*/
  /* mr = n ; nr = n ; */
  mr = k+1 ; nr = n ;
  if ( k == m )
    Rm = m ;
  else
    Rm = mr ;
  Rm = k ;

  /* mr = m ; nr = n ; Rm = n ; */

  /* copy the useful bit of A into R */
  for ( j = 0 ; j < nr ; j ++ ) {
    for ( i = 0 ; i <= MIN(mr,j) ; i ++ ) {
      R[matrix_index(mr, nr, i, j)] = A[matrix_index(m,n,i,j)] ;
    }
  }

  /*fill Q with the matrix generated by the reflectors*/
  memset(Q, 0, k*m*sizeof(gdouble)) ;
  for ( j = 0 ; j < k ; j ++ ) {
    Q[matrix_index(m, k, j, j)] = 1.0 ;
  }
  for ( i = k-1 ; i >= 0 ; i -- ) {
    gint nv, nc ;
    A[matrix_index(m,n,i,i)] = 1.0 ;
    nv = m - i ; nc = k - i ;
    dlarf_("L", &nv, &nc, &(A[matrix_index(m,n,i,i)]), &one,
  	   &(tau[i]), &(Q[matrix_index(m,k,i,i)]), &m, work) ;
  }

  /*tau is not used after this point*/
  
  /*make diagonals of R positive*/
  for ( i = 0 ; i < MIN(mr,nr) ; i ++ ) {
    tmp = -1.0 ;
    if ( R[matrix_index(mr,nr,i,i)] < 0 ) {
      blaswrap_dscal(nr, tmp, &(R[matrix_index(mr,nr,i,0)]), mr) ;
      blaswrap_dscal(m, tmp, &(Q[matrix_index(m,n,0,i)]), one) ;
    }
  }

  if ( k == n ) {
    *rank = k ;
    *ldr = mr ;
    fprintf(stderr, "rank == number of columns\n") ;
    return 0 ;
  }
  
  /*number of columns in R12*/
  n12 = nr - k ;

  gamma = &(work[0]) ;  
  omega = &(gamma[n-k]) ;
  AB    = &(omega[k]) ;
  
  /*linear solve with R11 and R12 packed in A upon exit from dgeqp3*/
  nab = nr - k ; mab = k ;
  for ( i = 0 ; i < mab ; i ++ ) {
    for ( j = 0 ; j < nab ; j ++ ) {
      AB[matrix_index(mab,nab,i,j)] = R[matrix_index(mr,nr,i,k+j)] ;
    }
  }

  /*initialize AB = A^{-1}B*/
  dtrtrs_("U", "N", "N", &k, &nab, R, &mr, AB, &mab, &info) ;

  memset(gamma, 0, (n-k)*sizeof(gdouble)) ;
  if ( k != m ) {
    for ( j = 0 ; j < MIN(n-k,m-1) ; j ++ ) {
      /* i = j + 1 ; */
      i = MIN(k+j, m) - k ;
      /* gdouble *ptr = &(A[matrix_index(m,n,k,k+j)]) ; */
      gamma[j] = blaswrap_dnrm2(i,&(A[matrix_index(m,n,k,k+j)]), one) ;
    }
  }

  /*copy R11 into work for inversion*/
  /* omega = &(AB[mab*nab]) ; */
  /* Atmp = &(omega[MAX(m,n)]) ; */
  Atmp = &(AB[mab*nab]) ;
  for ( i = 0 ; i < k ; i ++ ) {
    for ( j = 0 ; j < k ; j ++ ) {
      Atmp[matrix_index(k,k,i,j)] = R[matrix_index(mr,nr,i,j)] ;
    }
  }

  dtrtri_("U", "N", &k, Atmp, &k, &info) ;
  
  for ( i = 0 ; i < k ; i ++ ) {
    omega[i] = 1.0/blaswrap_dnrm2(k, &(Atmp[matrix_index(k,k,i,0)]), k) ;
  }

  /*Atmp not used after this*/
  
  len = MAX(m,n) ;
  iter = 0 ;
  while ( 1 ) {
    while ( 1 ) {
      iter ++ ;
      gint jj ;

      for ( j = 0 ; j < n12 ; j ++ ) {
	for ( i = 0 ; i < k ; i ++ ) {
	  tmp = gamma[j]/omega[i] ;
	  tmp *= tmp ;
	  tmp += AB[matrix_index(mab,nab,i,j)]*AB[matrix_index(mab,nab,i,j)] ;
	  g_assert(!isnan(tmp)) ;
	  if ( tmp > f*f ) { break ; }
	}
	if ( tmp > f*f ) { break ; }
      }

      /*no entry > f*f, so RRQR is strong */
      if ( tmp < f*f ) { break ; }

      if ( j > 0 ) {
	/*swap columns k and k+j*/
	tmp = gamma[0] ; gamma[0] = gamma[j] ; gamma[j] = tmp ;
	itmp = pvt[k] ; pvt[k] = pvt[k+j] ; pvt[k+j] = itmp ;
	column_swap(AB, mab, nab, 0, j) ;
	column_swap(R, mr, nr, k+0, k+j) ;
      }

      if ( i < k-1 ) {
	array_shuffle_int(pvt, k-1, i) ;
	array_shuffle_double(omega, k-1, i) ;
	column_shuffle(R, mr, k-1, i, mr) ;
	row_shuffle(AB, mab, nab, i, k-1, k) ;
	
	/*Givens rotations*/
	for ( ii = i ; ii < k-1 ; ii ++ ) {
	  ta = R[matrix_index(mr,nr,ii  ,ii)] ;
	  tb = R[matrix_index(mr,nr,ii+1,ii)] ;
	  drotg_(&ta, &tb, &Gc, &Gs) ;
	  if ( Gc*R[matrix_index(mr,nr,ii  ,ii)] +
	       Gs*R[matrix_index(mr,nr,ii+1,ii)] < 0.0 ) {
	    Gc = -Gc ; Gs = -Gs ;
	  }
	  drot_(&nr,
		&(R[matrix_index(mr,nr,ii  ,0)]), &mr,
		&(R[matrix_index(mr,nr,ii+1,0)]), &mr,
		&Gc, &Gs) ;
	  drot_(&m,
	  	&(Q[matrix_index(m,k,0,ii  )]), &one,
	  	&(Q[matrix_index(m,k,0,ii+1)]), &one,
	  	&Gc, &Gs) ;
	}
	if ( R[matrix_index(mr,nr,k-1,k-1)] < 0 ) {
	  for ( ii = 0 ; ii < nr ; ii ++ )
	    R[matrix_index(mr,nr,k-1,ii)] *= -1 ;
	  for ( ii = 0 ; ii < m ; ii ++ )
	    Q[matrix_index(m,k,ii,k-1)] *= -1 ;
	}
      }
      
      if ( k < Rm ) {
	for ( ii = k + 1 ; ii < Rm ; ii ++ ) {
	  ta = R[matrix_index(mr,nr,k ,k)] ;
	  tb = R[matrix_index(mr,nr,ii,k)] ;
	  drotg_(&ta, &tb, &Gc, &Gs) ;
	  
	  if ( Gc*R[matrix_index(mr,nr, k,k)] +
	       Gs*R[matrix_index(mr,nr,ii,k)] < 0.0 ) {
	    Gc = -Gc ; Gs = -Gs ;
	  }
	  drot_(&nr,
		&(R[matrix_index(mr,nr, k,0)]), &mr,
		&(R[matrix_index(mr,nr,ii,0)]), &mr,
		&Gc, &Gs) ;
	  drot_(&m,
	  	&(Q[matrix_index(m,k,0,k )]), &one,
	  	&(Q[matrix_index(m,k,0,ii)]), &one,
	  	&Gc, &Gs) ;
	}
      }
      itmp = pvt[k-1] ; pvt[k-1] = pvt[k] ; pvt[k] = itmp ;

      /* b1 = &(Atmp[k*k]) ; */
      /* b1 = &(Atmp[0]) ;  b2 = &(b1[len]) ; */
      b1 = &(AB[mab*nab]) ;  b2 = &(b1[len]) ;
      u1 = &(b2[len])   ;  u2 = &(u1[len]) ;
      c1T = &(u2[len])  ; c2T = &(c1T[len]) ;
      c1Tbar = &(c2T[len]) ; c2Tbar = &(c1Tbar[len]) ;
      
      ga = R[matrix_index(mr, nr, k-1, k-1)] ;
      mu = R[matrix_index(mr, nr, k-1, k  )]/ga ;
      if ( k < Rm ) {
	nu = R[matrix_index(mr, nr, k, k)]/ga ;
      } else {
	nu = 0.0 ;
      }
      rho = sqrt(mu*mu + nu*nu) ;
      
      ga_bar = ga*rho ;
      
      ii = k - 1 ;
      blaswrap_dcopy(ii, &(R[matrix_index(mr, nr, 0, k-1)]), one, b1, one) ;
      blaswrap_dcopy(ii, &(R[matrix_index(mr, nr, 0, k  )]), one, b2, one) ;
      blaswrap_dcopy(ii, b2, one, &(R[matrix_index(mr, nr, 0, k-1)]), one) ;
      blaswrap_dcopy(ii, b1, one, &(R[matrix_index(mr, nr, 0, k  )]), one) ;

      /* ii = nr - k - 1 ; */
      ii = n12 ;
      blaswrap_dcopy(ii, &(R[matrix_index(mr, nr, k-1, k+1)]), mr, c1T, one) ;
      if ( k+1 > Rm ) {
	memset(c2T, 0, ii*sizeof(gdouble)) ;	
      } else {
	blaswrap_dcopy(ii, &(R[matrix_index(mr, nr, k, k+1)]), mr, c2T, one) ;
      }

      for ( ii = 0 ; ii < n - k - 1 ; ii ++ ) {
      	c1Tbar[ii] = (mu*c1T[ii] + nu*c2T[ii])/rho ;
      	c2Tbar[ii] = (nu*c1T[ii] - mu*c2T[ii])/rho ;
      }

      R[matrix_index(mr,nr,k-1,k-1)] = ga_bar ;
      R[matrix_index(mr,nr,k-1,k  )] = ga*mu/rho ;
      R[matrix_index(mr,nr,k  ,k  )] = ga*nu/rho ;

      ii = n - k -1 ;
      blaswrap_dcopy(ii, c1Tbar, one,
		     &(R[matrix_index(mr, nr, k-1, k+1)]), mr) ;
      blaswrap_dcopy(ii, c2Tbar, one,
		     &(R[matrix_index(mr, nr, k  , k+1)]), mr) ;

      itmp = 1 ; jj = k - 1 ;
      dtrtrs_("U", "N", "N", &jj, &one, R, &mr, b1, &n, &info) ;
      for ( ii = 0 ; ii < k - 1 ; ii ++ ) {
	u1[ii] = AB[matrix_index(mab,nab,ii,0)] ;
	AB[matrix_index(mab,nab,ii,0)] = (nu*nu*b1[ii] - mu*u1[ii])/rho/rho ;
      }
      AB[matrix_index(mab,nab,k-1,0)] = mu/rho/rho ;
      for ( ii = 1 ; ii < nab ; ii ++ ) {
	AB[matrix_index(mab,nab,k-1,ii)] = c1Tbar[ii-1]/ga_bar ;
      }
      for ( ii = 0 ; ii < k-1 ; ii ++ ) {
	for ( jj = 1 ; jj < nab ; jj ++ ) {
	  AB[matrix_index(mab,nab,ii,jj)] +=
	    (nu*b1[ii]*c2Tbar[jj-1] - u1[ii]*c1Tbar[jj-1])/ga_bar ;
	}
      }

      gamma[0] = ga*nu/rho ;
      for ( ii = 1 ; ii < n12 ; ii ++ ) {
	gamma[ii] = sqrt(gamma[ii]*gamma[ii] +
			 c2Tbar[ii-1]*c2Tbar[ii-1] -
			 c2T[ii-1]*c2T[ii-1]) ;
      }

      ii = k - 1 ; 
      blaswrap_daxpy(ii,mu,b1,one,u1,one) ;
		     
      omega[k-1] = ga_bar ;
      for ( ii = 0 ; ii < k -1 ; ii ++ ) {
	omega[ii] = 1.0/sqrt(1.0/(omega[ii]*omega[ii]) +
			     u1[ii]*u1[ii]/ga_bar/ga_bar -
			     b1[ii]*b1[ii]/ga/ga) ;
	if ( isnan(omega[ii]) ) {
	  g_error("NaN") ;
	}
	g_assert(!isnan(omega[ii])) ;
      }
      if ( k < Rm ) {
	gdouble Q1, Q2 ;
	for ( ii = 0 ; ii < m ; ii ++ ) {
	  Q1 = Q[matrix_index(m,k,ii,k-1)] ;
	  Q2 = Q[matrix_index(m,k,ii,k  )] ;
	  Q[matrix_index(m,k,ii,k-1)] = (Q1*mu + Q2*nu)/rho ;
	  Q[matrix_index(m,k,ii,k  )] = (Q1*nu - Q2*mu)/rho ;
	}
      }
    }

    tmp = G_MAXDOUBLE ;
    for ( ii = 0 ; ii < k - 1 ; ii ++ ) {
      if ( omega[ii] < tmp ) {
	tmp = omega[ii] ; i = ii ;
      }
    }
  
    if ( tmp > tol ) {
      /* return 0 ; */
      /* fprintf(stderr, "%d %lg\n", i, tmp) ; */
      break ;
    }

    break ;
    /*untested code past this point (no test input available)*/
    g_assert_not_reached() ;
  
    if ( i < k - 1 ) {
      array_shuffle_int(pvt, k-1, i) ;
      column_shuffle(R, mr, k-1, i, mr) ;
      for ( ii = i ; ii < k-1 ; ii ++ ) {
	ta = R[matrix_index(mr,nr,ii  ,ii)] ;
	tb = R[matrix_index(mr,nr,ii+1,ii)] ;
	drotg_(&ta, &tb, &Gc, &Gs) ;
	if ( Gc*R[matrix_index(mr,nr,ii  ,ii)] +
	     Gs*R[matrix_index(nr,nr,ii+1,ii)] < 0.0 ) {
	  Gc = -Gc ; Gs = -Gs ;
	}
	drot_(&n,
	      &(R[matrix_index(mr,nr,ii  ,0)]), &mr,
	      &(R[matrix_index(mr,nr,ii+1,0)]), &mr,
	      &Gc, &Gs) ;
      }
      if ( R[matrix_index(mr,nr,k-1,k-1)] < 0 ) {
	for ( ii = 0 ; ii < n ; ii ++ )
	  R[matrix_index(mr,nr,k-1,ii)] *= -1 ;
	/*needs to be applied to Q as well*/
      }
      k -- ;    
    }
  
    nab = n - k ; mab = k ;
    for ( i = 0 ; i < mab ; i ++ ) {
      for ( j = 0 ; j < nab ; j ++ ) {
	AB[matrix_index(mab,nab,i,j)] = R[matrix_index(mr,nr,i,k+j)] ;
      }
    }
  
    dtrtrs_("U", "N", "N", &k, &nab, R, &mr, AB, &mab, &info) ;

    for ( j = 0 ; j < MIN(m,n)-k ; j ++ ) {
      for ( i = k ; i < k+j+1 ; i ++ ) {
	gamma[j] +=
	  R[matrix_index(mr,nr,i,k+j)]*R[matrix_index(mr,nr,i,k+j)] ;
      }
      gamma[j] = sqrt(gamma[j]) ;
    }
    for ( i = 0 ; i < k ; i ++ ) {
      for ( j = 0 ; j < k ; j ++ ) {
	work[matrix_index(k,k,i,j)] = R[matrix_index(mr,nr,i,j)] ;
      }
    }

    dtrtri_("U", "N", &k, work, &k, &info) ;
    for ( i = 0 ; i < k ; i ++ ) {
      omega[i] =
	1.0/blaswrap_dnrm2((k), &(work[matrix_index(k,k,i,0)]),
			   (k)) ;
    }
    fprintf(stderr, "loop end\n") ;
  }

  *rank = k ;
  *ldr = mr ;
  
  return 0 ;
}
